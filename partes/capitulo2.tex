\chapter{Marco Teórico}
\label{capitulo2}
\lhead{Capítulo 2. \emph{Marco Teórico}}

A continuación se detallan los aspectos teóricos sobre los cuales se basan
tanto las herramientas utilizadas en la pasantía como la solución propuesta
en este proyecto:

\section{API}
Un API (\emph{Application Programming Interface}) es un conjunto de comandos,
funciones, protocolos o métodos que le permiten a un programa comunicarse
con un sistema externo o librería. Las APIs permiten que varios sistemas
informáticos (Sistemas Operativos, aplicaciones, etc.) se comuniquen sin la
necesidad de exponer la funcionalidad interna de cada sistema. A su vez esto
le permite a los desarrolladores utilizar funcionalidades de otras aplicaciones
sin la necesidad de reescribir código (\cite{API}).

\section{Bases de datos relacional}

Una base de datos es un medio para almacenar y recuperar información. En términos simples
una base de datos relacional es aquella en la que la información es almacenada en tablas con
filas y columnas. Se le hace referencia a las tablas como relaciones ya que representa una
coleccion de objetos del mismo tipo. La habilidad de recuperar información relacionada de una
tabla es la base para el término Base de datos relacional (\cite{RELACIONAL}).

\section{Manejador de Base de datos}
Los manejadores de bases de datos son aplicaciones de software que cumplen con la función
de gestionar la comunicación entre los usuarios y las aplicaciones con las base de datos.
Los manejadores ofrecen una interfaz que permite definir, crear, consultar, actualizar
y administrar distintas bases de datos.

\section{Desarrollo Orientado a Componentes}

Este método de diseño de software establece que a la hora de construir un sistema
informático, las funcionalidades de éste sean separadas en unidades más pequeñas
llamadas componentes. Un componente es una pieza de software que ofrece a través
de una interfaz un servicio predefinido y que es capaz de comunicarse con otros
componentes (\cite{COMPONENT}). Esta estrategia de desarrollo trae como resultado
software que puede ser reutilizado con mayor facilidad y que es fácilmente escalable
agregando futuros componentes que agreguen nuevas funcionalidades. Además, facilita la
mantenibilidad del código debido a varios factores, entre los que destacan la encapsulación
de funcionalidades, la alta cohesión y el bajo acoplamiento entre los componentes de
software manejados en este método.

\section{Lenguaje de marcado}

Un lenguaje de marcas es un lenguaje que anota el texto de modo que el ordenador puede manipularlo.
Al dar formato al texto que se desea mostrar es necesario distinguir entre el texto en sí
y las instrucciones para imprimir el texto. Las marcas de este tipo de lenguajes son las
instrucciones para mostrar o imprimir el texto (\cite{MARCADO}).

\section{Plantillas declarativas}

La técnica de plantillas declarativas implica emular un lenguaje de marcado dentro de un
lenguaje de programación. Esta estrategia nos permite que en un solo archivo podamos
escribir el texto a mostrar con la misma sintáxis de un lenguaje de marcado ya conocido,
con la posibilidad de además utilizar ciertas instrucciones del lenguaje de programación
para definir comportamientos deseados sobre el texto a mostrar.

\section{Inyección de dependencias}

En las arquitecturas orientadas a componentes surge el problema de la resolución de
dependencias. Cuando un sistema crece también crece el número de componentes que lo
conforman. Ésto complica cada vez más el proceso de resolución de dependencias, es decir,
encontrar los servicios y componentes de los cuales depende un elemento en particular.

El patrón de diseño de Inyección de dependencias busca resolver este problema. La
idea básica detrás de la inyección de dependencias es la de tener un objeto separado
que se encargue de monitorear las dependencias de cada componente, encontrar
servicios que provean éstas dependencias y conectarlos con el componente (\cite{INYECCION}).

\section{Modelo Vista Controlador}
Modelo-Vista-Controlador (MVC) es un patrón de diseño de software, especialmente útil
para diseñar interfaces de usuario. Se basa en la separación de los datos y lógica de
negocio, la interfaz gráfica a mostrar y el módulo encargado de atender y responder a
los eventos generados por el usuario en tres componentes distintos (\cite{MVC}). Estos
componentes quedan definidos de la siguiente manera:

\begin{itemize}
  \item \textbf{Modelo}: se encarga de representar los datos que maneja el sistema y
  la funcionalidad asociada que tengan estos modelos.
  \item \textbf{Vista}: está a cargo de mostrar la representación visual del modelo
  para que el usuario interactúe fácilmente con el sistema.
  \item \textbf{Controlador}: es el módulo encargado de coordinar las vistas con el modelo.
  Para ello atiende los eventos que pueda generar el usuario para luego actualizar
  adecuadamente la vista y el modelo.
\end{itemize}

Este patrón de arquitectura de software se ha vuelto bastante común en el desarrollo
de interfaces de usuario por su ventajas en cuanto a reutilización y mantenibilidad
del código.

\section{Gestor para control de versiones}

El control de versiones puede ser definido como el manejo de los cambios a documentos,
archivos o cualquier otra colección de información. Un gestor de control de versiones
se encarga de registrar e identificar las versiones de un archivo en específico, marcando
además el autor y el momento en el que fueron realizadas las modificaciones. Esto permite
que las distintas versiones del documento puedan ser luego comparadas, restauradas, y en
algunos casos, mezcladas (\cite{VERSION}).
